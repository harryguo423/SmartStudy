=<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>å•è¯å­¦ä¹ </title>
  <style>
    body { font-family: sans-serif; padding: 2em; }
    #options {
  display: flex;
  flex-wrap: wrap;
  gap: 2%;
  justify-content: space-between;
}

button.option {
  flex: 0 1 23%;  /* å å®½çº¦1/4ï¼ˆåŠ gapæ›´è‡ªç„¶ï¼‰ */
  box-sizing: border-box;
  padding: 10px;
  word-wrap: break-word;
  white-space: normal;
  text-align: center;
  border-radius: 1rem;
  font-size:1rem;
  margin-bottom:3rem;
}

button.option.correct {
  border: 2px solid #28a745;
  background-color: #e8f5e9;
  position: relative;
  border-radius: 1rem;
  transition: all 0.2s ease;
}

button.option.correct::after {
  content: "";
  position: absolute;
  top: -6px;
  left: -6px;
  right: -6px;
  bottom: -6px;
  border: 2px solid #28a745;
  border-radius: 1rem;
  opacity: 0.6;
  animation: pulseOutGreen 0.5s ease-out forwards;
  pointer-events: none;
}

button.option.wrong {
  border: 2px solid #dc3545;
  background-color: #f8d7da;
  position: relative;
  border-radius: 1rem;
  transition: all 0.2s ease;
}

button.option.wrong::after {
  content: "";
  position: absolute;
  top: -6px;
  left: -6px;
  right: -6px;
  bottom: -6px;
  border: 2px solid #dc3545;
  border-radius: 1rem;
  opacity: 0.6;
  animation: pulseOutRed 0.5s ease-out forwards;
  pointer-events: none;
}

@keyframes pulseOutGreen {
  0% { transform: scale(1); opacity: 0.6; }
  100% { transform: scale(1.2); opacity: 0; }
}

@keyframes pulseOutRed {
  0% { transform: scale(1); opacity: 0.6; }
  100% { transform: scale(1.2); opacity: 0; }
}


button.option.selected::after {
  content: "";
  position: absolute;
  top: -6px;
  left: -6px;
  right: -6px;
  bottom: -6px;
  border: 2px solid #007bff;
  border-radius: 1rem;
  opacity: 0.6;
  animation: pulseOut 0.5s ease-out forwards;
  pointer-events: none;
}

@keyframes pulseOut {
  0% {
    transform: scale(1);
    opacity: 0.6;
    border-radius:1rem;
  }
  100% {
    transform: scale(1.2);
    opacity: 0;border-radius:1rem;
  }
}

#nav-buttons {
  display: flex;
  justify-content: center;
  gap: 1.5rem;
  margin-top: 2rem;
}

button.option:hover ,button.option.hover {
  background-color:  rgba(0, 123, 255, 0.3);
  transform: scale(1.05);
  transition: all 0.2s ease;
  box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
}


.nav-button {
  background-color: #f0f0f0;
  border: 2px solid #007bff;
  border-radius: 8px;
  padding: 0.6em 1.2em;
  font-size: 1rem;
  font-weight: bold;
  color: #007bff;
  cursor: pointer;
  transition: all 0.2s ease;
}

#word {
  text-align: center;
  font-size: 3rem;
  margin-top:2rem;
  margin-bottom: 5rem;
}


.nav-button:hover,.nav-button.hover,
.nav-button:focus  {
  background-color: #007bff;
  color: white;
  transform: scale(1.05);
}

.nav-button:active {
  transform: scale(0.97);
}

    .hidden { display: none; }
    .learned { color: green; font-weight: bold; }
    #progress-bar div { height: 20px; }
  </style>
</head>
<body>
  
  <h2 id="word">åŠ è½½ä¸­...</h2>
  <div id="options"></div>
  <div id="feedback" class="hidden"></div>
  <div id="nav-buttons">
    <button class="nav-button" onclick="prevWord()">â¬…ï¸ ä¸Šä¸€ä¸ªå•è¯</button>
    <button class="nav-button" onclick="nextWord()">ä¸‹ä¸€ä¸ªå•è¯ â¡ï¸</button>
  </div>
  
  <div style="margin-top:2rem"></div>
  <div id="progress-bar" style="display: flex; gap: 2px; margin-top: 30px; border-radius: 10rem; overflow: hidden;"></div>

<!-- çŠ¶æ€ä¸æ¨¡å¼é€‰æ‹© -->
<div id="status-mode" style="display: flex; justify-content: space-between; font-size: 1rem; margin-top: 1rem;">
  <div id="status">å·²å­¦ä¼šï¼š0/0</div>
  <label>
    æ¨¡å¼é€‰æ‹©ï¼š
    <select id="modeSelector" onchange="switchMode()">
      <option value="learn">ğŸ§  å­¦ä¹ æ¨¡å¼</option>
      <option value="review">ğŸ“˜ å¤ä¹ æ¨¡å¼</option>
    </select>
  </label>
</div>

<!-- æ–°å¢ï¼šè¯è¡¨é€‰æ‹©ä¸‹æ‹‰æ¡† -->
<div id="vocab-selection" style="margin-bottom: 1rem;">
  <label>
    é€‰æ‹©è¯è¡¨ï¼š
    <select id="vocabSelector" onchange="loadSelectedVocab()">
      <option value="">-- è¯·é€‰æ‹©è¯è¡¨ --</option>
    </select>
  </label>
  <span id="vocabFeedback" style="color: #dc3545; margin-left: 10px;"></span>
</div>

<!-- æ–°å¢ï¼šåˆ›å»ºè¯è¡¨æŒ‰é’®ï¼ˆæ’å…¥åˆ°ã€Œè®¾ç½®è¿›åº¦ã€æŒ‰é’®ä¸‹æ–¹ï¼‰ -->
<div id="vocab-creation" style="margin-top: 1.5rem; display: flex; gap: 1rem;">
  <button class="nav-button" onclick="addCurrentWordToTemp()">â• åŠ å…¥é‡ç‚¹è¯</button>
  <button class="nav-button" onclick="createNewVocab()" style="background-color: #28a745; color: white; border-color: #28a745;">ğŸ“ åˆ›å»ºè¯è¡¨</button>
  <span id="tempVocabStatus" style="color: #28a745; align-self: center;"></span>
  </div>

<div id="progress-input" style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">
  <label>è®¾ç½®å½“å‰å­¦ä¹ è¿›åº¦è‡³å•è¯å·ï¼š</label>
  <input type="number" id="wordNumber" min="1" placeholder="è¾“å…¥å•è¯å·" style="width: 100px; padding: 5px;">
  <button class="nav-button" onclick="setLearningProgress()">è®¾ç½®è¿›åº¦</button>
  <div id="progressFeedback" style="color: #dc3545; margin-left: 10px;"></div>
</div>

  <script>
    let words = [];
    let index = 0;
    let batchSize = 20;
    let currentBatchStart = 0;
    let progress = {};
    let reviewProgress = {};
    let mode = 'learn';
    
    const PROGRESS_KEY = "wordProgress";
    const REVIEW_KEY = "reviewProgress";
    
    
    
    
    // æ–°å¢ï¼šä¸´æ—¶è¯è¡¨ç›¸å…³å˜é‡
let tempVocab = []; // ä¸´æ—¶é‡ç‚¹è¯è¡¨ï¼ˆå»é‡ï¼‰
let currentVocabName = ""; // å½“å‰é€‰ä¸­çš„è¯è¡¨å

// é¡µé¢åŠ è½½æ—¶å…ˆè·å–è¯è¡¨åˆ—è¡¨
window.onload = () => {
  loadVocabList(); // åŠ è½½æ‰€æœ‰è¯è¡¨åˆ°ä¸‹æ‹‰æ¡†
};

// åŸæœ‰ï¼šfetch("/api/words") æ”¹ä¸ºæ ¹æ®é€‰ä¸­è¯è¡¨åŠ è½½ï¼Œæ•…æ³¨é‡ŠåŸæœ‰fetchï¼Œæ–°å¢ä»¥ä¸‹å‡½æ•°
// æ–°å¢ï¼šåŠ è½½è¯è¡¨åˆ—è¡¨åˆ°ä¸‹æ‹‰æ¡†
function loadVocabList() {
  fetch("/api/vocab-lists")
    .then(res => res.json())
    .then(lists => {
      const selector = document.getElementById("vocabSelector");
      selector.innerHTML = '<option value="">-- è¯·é€‰æ‹©è¯è¡¨ --</option>'; // æ¸…ç©ºåŸæœ‰é€‰é¡¹
      // æ–°å¢æ‰€æœ‰è¯è¡¨é€‰é¡¹
      lists.forEach(list => {
        const option = document.createElement("option");
        option.value = list.name;
        option.textContent = list.label;
        selector.appendChild(option);
      });
    })
    .catch(err => {
      document.getElementById("vocabFeedback").textContent = "åŠ è½½è¯è¡¨åˆ—è¡¨å¤±è´¥";
    });
}

// æ–°å¢ï¼šåŠ è½½é€‰ä¸­çš„è¯è¡¨
function loadSelectedVocab() {
  const selector = document.getElementById("vocabSelector");
  const feedback = document.getElementById("vocabFeedback");
  currentVocabName = selector.value;

  if (!currentVocabName) {
    feedback.textContent = "è¯·é€‰æ‹©è¯è¡¨";
    document.getElementById("word").textContent = "è¯·é€‰æ‹©è¯è¡¨";
    document.getElementById("options").innerHTML = "";
    return;
  }

  // è°ƒç”¨åç«¯æ¥å£è·å–é€‰ä¸­è¯è¡¨çš„å•è¯
  fetch(`/api/words?vocabName=${encodeURIComponent(currentVocabName)}`)
    .then(res => {
      if (!res.ok) throw new Error("è¯è¡¨åŠ è½½å¤±è´¥");
      return res.json();
    })
    .then(data => {
      words = data;
      loadProgress();
      loadReviewProgress();
      initializeProgress(data);
      index = 0;
      currentBatchStart = 0;
      renderWord();
      feedback.textContent = ""; // æ¸…ç©ºé”™è¯¯æç¤º
    })
    .catch(err => {
      feedback.textContent = err.message;
    });
}

// æ–°å¢ï¼šå°†å½“å‰å•è¯åŠ å…¥ä¸´æ—¶è¯è¡¨ï¼ˆå»é‡ï¼‰
function addCurrentWordToTemp() {
  if (words.length === 0 || !currentVocabName) {
    document.getElementById("tempVocabStatus").textContent = "è¯·å…ˆé€‰æ‹©å¹¶åŠ è½½è¯è¡¨";
    setTimeout(() => document.getElementById("tempVocabStatus").textContent = "", 3000);
    return;
  }

  const currentWordData = getWordsToStudy()[index % getWordsToStudy().length];
  // å»é‡ï¼šåˆ¤æ–­ä¸´æ—¶è¯è¡¨ä¸­æ˜¯å¦å·²æœ‰è¯¥å•è¯ï¼ˆæŒ‰â€œå•è¯â€å­—æ®µåˆ¤æ–­ï¼‰
  const isDuplicate = tempVocab.some(item => item.å•è¯ === currentWordData.å•è¯);

  if (isDuplicate) {
    document.getElementById("tempVocabStatus").textContent = "è¯¥å•è¯å·²åœ¨ä¸´æ—¶è¯è¡¨ä¸­";
  } else {
    tempVocab.push(currentWordData);
    document.getElementById("tempVocabStatus").textContent = `âœ… å·²æ·»åŠ ï¼ä¸´æ—¶è¯è¡¨å…±${tempVocab.length}ä¸ªå•è¯`;
  }

  // 3ç§’åæ¸…ç©ºæç¤º
  setTimeout(() => document.getElementById("tempVocabStatus").textContent = "", 3000);
}

// æ–°å¢ï¼šåˆ›å»ºæ–°è¯è¡¨ï¼ˆå°†ä¸´æ—¶è¯è¡¨ä¿å­˜ä¸ºjsonæ–‡ä»¶ï¼‰
function createNewVocab() {
  if (tempVocab.length === 0) {
    document.getElementById("tempVocabStatus").textContent = "ä¸´æ—¶è¯è¡¨ä¸ºç©ºï¼Œæ— æ³•åˆ›å»º";
    setTimeout(() => document.getElementById("tempVocabStatus").textContent = "", 3000);
    return;
  }

  // è°ƒç”¨åç«¯æ¥å£åˆ›å»ºæ–°è¯è¡¨
  fetch("/api/create-vocab", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ words: tempVocab })
  })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        document.getElementById("tempVocabStatus").textContent = `ğŸ‰ è¯è¡¨åˆ›å»ºæˆåŠŸï¼ï¼ˆ${data.vocabName}ï¼‰`;
        tempVocab = []; // æ¸…ç©ºä¸´æ—¶è¯è¡¨
        loadVocabList(); // åˆ·æ–°è¯è¡¨åˆ—è¡¨ï¼Œè®©æ–°åˆ›å»ºçš„è¯è¡¨å¯é€‰ä¸­
      } else {
        document.getElementById("tempVocabStatus").textContent = data.error || "åˆ›å»ºå¤±è´¥";
      }
    })
    .catch(err => {
      document.getElementById("tempVocabStatus").textContent = "åˆ›å»ºè¯è¡¨å‡ºé”™";
    });

  setTimeout(() => document.getElementById("tempVocabStatus").textContent = "", 3000);
}

// æ³¨é‡ŠåŸæœ‰ç›´æ¥åŠ è½½wordsçš„fetchä»£ç ï¼ˆæ›¿æ¢ä¸ºæŒ‰è¯è¡¨åŠ è½½ï¼‰
// åŸæœ‰ä»£ç ï¼šfetch("/api/words").then(res => res.json()).then(data => { ... });(
    
    
    function saveProgress() {
      localStorage.setItem(PROGRESS_KEY, JSON.stringify(progress));
    }
    
    function saveReviewProgress() {
      localStorage.setItem(REVIEW_KEY, JSON.stringify(reviewProgress));
    }
    
    function loadProgress() {
      const raw = localStorage.getItem(PROGRESS_KEY);
      if (raw) progress = JSON.parse(raw);
    }
    
    function loadReviewProgress() {
      const raw = localStorage.getItem(REVIEW_KEY);
      if (raw) reviewProgress = JSON.parse(raw);
    }
    
    function initializeProgress(data) {
      if (!progress) progress = {};
      data.forEach(w => {
        if (!(w.å•è¯ in progress)) progress[w.å•è¯] = { streak: 0 };
      });
    }
    
  ==
    
    function shuffle(arr) {
  // Fisher-Yates shuffle
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function getWordsToStudy() {
  if (mode === 'learn') {
    const batch = words.slice(currentBatchStart, currentBatchStart + batchSize);
    const unlearned = batch.filter(w => progress[w.å•è¯].streak < 3);
    shuffle(unlearned);
    return unlearned;
  } else {
    const reviewing = words.filter(w =>
      progress[w.å•è¯]?.streak >= 3 && (reviewProgress[w.å•è¯]?.review ?? 0) > 0
    );
    shuffle(reviewing);
    return reviewing;
  }
}

    
function renderWord() {
  const list = getWordsToStudy();

  const learnedCount = Object.values(progress).filter(p => p.streak >= 3).length;
  const totalCount = words.length;
  const reviewedCount = words.filter(w =>
    progress[w.å•è¯]?.streak >= 3 && (reviewProgress[w.å•è¯]?.review ?? 0) === 0
  ).length;

  if (list.length === 0) {
    if (mode === 'learn') {
      if (currentBatchStart + batchSize >= totalCount) {
        document.getElementById("status").innerHTML = `ğŸ‰ æ‰€æœ‰å•è¯å·²å­¦å®Œï¼ï¼ˆå…± ${learnedCount}/${totalCount}ï¼‰`;
        document.getElementById("word").textContent = "";
        
        document.getElementById("options").innerHTML = "";
        document.getElementById("feedback").classList.add("hidden");
        return;
      } else {
        currentBatchStart += batchSize;
        index = 0;
        renderWord();
        return;
      }
    } else {
      document.getElementById("status").innerHTML = `âœ… å¤ä¹ å®Œæˆï¼ï¼ˆå…±å¤ä¹  ${reviewedCount}/${totalCount}ï¼‰`;
      document.getElementById("word").textContent = "";
      document.getElementById("options").innerHTML = "";
      document.getElementById("feedback").classList.add("hidden");
      return;
    }
  }

  const word = list[index % list.length];
  document.getElementById("word").textContent = word.å•è¯;
  const wordText = document.getElementById("word");
wordText.innerHTML = `${word.å•è¯} <button id="speakBtn" style="font-size: 0.6em;">ğŸ”Š</button>`;

document.getElementById("speakBtn").onclick = () => {
  speakWord(word.å•è¯);
};

  document.getElementById("word").dataset.correct = word.å•è¯é‡Šä¹‰;
  document.getElementById("feedback").classList.add("hidden");

  const correct = word.å•è¯é‡Šä¹‰;
  let options = [correct];
  while (options.length < 4) {
    let rand = words[Math.floor(Math.random() * words.length)].å•è¯é‡Šä¹‰;
    if (!options.includes(rand)) options.push(rand);
  }
  options.sort(() => Math.random() - 0.5);

  const container = document.getElementById("options");
  container.innerHTML = "";
  options.forEach((opt, i) => {
    const btn = document.createElement("button");
    btn.className = "option";
    btn.textContent = opt;
    btn.onclick = () => {
      const isCorrect = opt === correct;
      highlightOption(i, isCorrect);
      handleAnswer(isCorrect, word);
    };
    container.appendChild(btn);
  });

  document.getElementById("status").textContent =
    mode === 'learn'
      ? `å·²å­¦ä¼šï¼š${learnedCount}/${totalCount}`
      : `å¤ä¹ ä¸­ï¼š${list.length} ä¸ªå•è¯`;

  renderProgressBar();
  speakWord(word.å•è¯);

}




function setLearningProgress() {
  const input = document.getElementById("wordNumber");
  const feedback = document.getElementById("progressFeedback");
  const maxWordNumber = words.length; // æ€»å•è¯æ•°
  const targetNumber = parseInt(input.value.trim(), 10);

  // è¾“å…¥éªŒè¯
  if (!targetNumber || isNaN(targetNumber) || targetNumber < 1) {
    feedback.textContent = "è¯·è¾“å…¥æœ‰æ•ˆçš„å•è¯å·ï¼ˆè‡³å°‘ä¸º1ï¼‰";
    return;
  }

  if (targetNumber > maxWordNumber) {
    feedback.textContent = `å•è¯å·ä¸èƒ½è¶…è¿‡æ€»å•è¯æ•°ï¼ˆ${maxWordNumber}ï¼‰`;
    return;
  }

  // é‡ç½®æ‰€æœ‰å•è¯çš„å­¦ä¹ è¿›åº¦
  for (let i = 0; i < maxWordNumber; i++) {
    const word = words[i];
    if (word && word.å•è¯) {
      // å¯¹äºç›®æ ‡å•è¯å·ä¹‹å‰çš„å•è¯æ ‡è®°ä¸ºå·²å®Œæˆ
      // ç›®æ ‡åŠä¹‹åçš„å•è¯æ ‡è®°ä¸ºæœªå®Œæˆ
      if (i < targetNumber - 1) {
        progress[word.å•è¯] = { streak: 3 }; // å·²å®Œæˆ
      } else {
        progress[word.å•è¯] = { streak: 0 }; // æœªå®Œæˆ
      }
    }
  }

  // è®¾ç½®å½“å‰å•è¯ç´¢å¼•ä¸ºç›®æ ‡å•è¯å· - 1ï¼ˆå› ä¸ºæ•°ç»„ä»0å¼€å§‹ï¼‰
  currentWordIndex = targetNumber - 1;

  // ä¿å­˜è¿›åº¦å¹¶åˆ·æ–°æ˜¾ç¤º
  saveProgress();
  renderProgressBar();
  renderWord(); // é‡æ–°æ¸²æŸ“å½“å‰å•è¯

  // åé¦ˆæˆåŠŸä¿¡æ¯
  feedback.textContent = `å·²æˆåŠŸè®¾ç½®å­¦ä¹ è¿›åº¦è‡³å•è¯å· ${targetNumber}`;
  input.value = "";
  
  // 3ç§’åæ¸…é™¤åé¦ˆä¿¡æ¯
  setTimeout(() => {
    feedback.textContent = "";
  }, 3000);
}




function handleAnswer(isCorrect, word) {
  const feedback = document.getElementById("feedback");
  const audio = new Audio(isCorrect ? "/correct.wav" : "/wrong.wav");
  audio.play();

  if (isCorrect) {
    if (mode === 'learn') {
      progress[word.å•è¯].streak++;
      if (progress[word.å•è¯].streak > 3) progress[word.å•è¯].streak = 3;
      saveProgress();
    } else {
      if (!reviewProgress[word.å•è¯]) reviewProgress[word.å•è¯] = { review: 1 };
      reviewProgress[word.å•è¯].review--;
      if (reviewProgress[word.å•è¯].review < 0) reviewProgress[word.å•è¯].review = 0;
      saveReviewProgress();
    }
    feedback.textContent = `âœ… æ­£ç¡®ï¼è”æƒ³æ³•ï¼š${word.å•è¯è”æƒ³èƒŒè¯µæ³•}`;
  } else {
    if (mode === 'learn') {
      progress[word.å•è¯].streak = 0;
      saveProgress();
    } else {
      reviewProgress[word.å•è¯] = { review: 3 };
      saveReviewProgress();
    }
    feedback.textContent = `âŒ é”™è¯¯ï¼è”æƒ³æ³•ï¼š${word.å•è¯è”æƒ³èƒŒè¯µæ³•}`;
  }

  feedback.classList.remove("hidden");
}

function speakWord(text) {
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = "en-US";
 //  speechSynthesis.speak(utter);
}

    
    function nextWord() {
      index++;
      renderWord();
    }
    
    function prevWord() {
      const list = getWordsToStudy();
      index = (index - 1 + list.length) % list.length;
      renderWord();
    }
    
    function switchMode() {
      mode = document.getElementById("modeSelector").value;
      index = 0;
      currentBatchStart = 0;
    
      if (mode === 'review') {
        words.forEach(w => {
          if (progress[w.å•è¯]?.streak >= 3 && !(w.å•è¯ in reviewProgress)) {
            reviewProgress[w.å•è¯] = { review: 1 };
          }
        });
        saveReviewProgress();
      }
    
      renderWord();
    }
    
    function renderProgressBar() {
      const bar = document.getElementById("progress-bar");
      bar.innerHTML = "";
    
      let total = words.length;
      let learned = 0;
      let learning = 0;
    
      if (mode === 'learn') {
        words.forEach(w => {
          let s = progress[w.å•è¯]?.streak ?? 0;
          if (s >= 3) learned++;
          else if (s > 0) learning++;
        });
      } else {
        words.forEach(w => {
          if (progress[w.å•è¯]?.streak >= 3) {
            let r = reviewProgress[w.å•è¯]?.review ?? 0;
            if (r === 0) learned++;
            else learning++;
          }
        });
      }
    
      let learnedPct = (learned / total) * 100;
      let learningPct = (learning / total) * 100;
      let unlearnedPct = 100 - learnedPct - learningPct;
    
      const addSegment = (color, width) => {
        const div = document.createElement("div");
        div.style.width = `${width}%`;
        div.style.height = "20px";
        div.style.backgroundColor = color;
        bar.appendChild(div);
      };
    
      addSegment("#007bff", learnedPct);   // è“è‰²ï¼šå·²å­¦ä¼š
      addSegment("#ffc107", learningPct);  // é»„è‰²ï¼šæ­£åœ¨å­¦
      addSegment("#ccc", unlearnedPct);    // ç°è‰²ï¼šæœªå­¦
    }
    
    function highlightOption(index, isCorrect) {
      const options = document.querySelectorAll("#options button.option");
      options.forEach(btn => btn.classList.remove("correct", "wrong"));
    
      if (options[index]) {
        options[index].classList.add(isCorrect ? "correct" : "wrong");
        setTimeout(() => {
          options[index].classList.remove("correct", "wrong");
        }, 500);
      }
    }
   
    

    document.addEventListener("keydown", (e) => {
  const key = e.key;

  if (key === "ArrowLeft") {
    const btn = document.querySelector(".nav-button:nth-child(1)");
    btn.classList.add("hover");
    setTimeout(() => btn.classList.remove("hover"), 150);
    prevWord();
    return;
  } else if (key === "ArrowRight") {
    const btn = document.querySelector(".nav-button:nth-child(2)");
    btn.classList.add("hover");
    setTimeout(() => btn.classList.remove("hover"), 150);
    nextWord();
    return;
  }

  // 1-4 å’Œ Enter çš„æ¨¡æ‹Ÿ hover/focus æ•ˆæœ
  let i = -1;
  if (["1", "2", "3", "4"].includes(key)) {
    i = parseInt(key, 10) - 1;
  } else if (key === "Enter") {
    i = 3; // Enter ç›¸å½“äºé€‰æ‹©ç¬¬ 4 é¡¹
  }

  if (i !== -1) {
    const options = document.querySelectorAll("#options button.option");
    if (options[i]) {
      const correctAnswer = document.getElementById("word").dataset.correct;

      // æ·»åŠ  hover æ•ˆæœ
      options[i].classList.add("hover");
      setTimeout(() => options[i].classList.remove("hover"), 150);

      highlightOption(i, options[i].textContent === correctAnswer);
      options[i].click();
    }
  }
});


    </script>
    
</body>
</html>
