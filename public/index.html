<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>å•è¯å­¦ä¹ </title>
  <style>
    body { font-family: sans-serif; padding: 2em; }
    #options {
  display: flex;
  flex-wrap: wrap;
  gap: 2%;
  justify-content: space-between;
}

button.option {
  flex: 0 1 23%;  /* å å®½çº¦1/4ï¼ˆåŠ gapæ›´è‡ªç„¶ï¼‰ */
  box-sizing: border-box;
  padding: 10px;
  word-wrap: break-word;
  white-space: normal;
  text-align: center;
  border-radius: 1rem;
  font-size:1rem;
  margin-bottom:3rem;
}

button.option.correct {
  border: 2px solid #28a745;
  background-color: #e8f5e9;
  position: relative;
  border-radius: 1rem;
  transition: all 0.2s ease;
}

button.option.correct::after {
  content: "";
  position: absolute;
  top: -6px;
  left: -6px;
  right: -6px;
  bottom: -6px;
  border: 2px solid #28a745;
  border-radius: 1rem;
  opacity: 0.6;
  animation: pulseOutGreen 0.5s ease-out forwards;
  pointer-events: none;
}

button.option.wrong {
  border: 2px solid #dc3545;
  background-color: #f8d7da;
  position: relative;
  border-radius: 1rem;
  transition: all 0.2s ease;
}

button.option.wrong::after {
  content: "";
  position: absolute;
  top: -6px;
  left: -6px;
  right: -6px;
  bottom: -6px;
  border: 2px solid #dc3545;
  border-radius: 1rem;
  opacity: 0.6;
  animation: pulseOutRed 0.5s ease-out forwards;
  pointer-events: none;
}

@keyframes pulseOutGreen {
  0% { transform: scale(1); opacity: 0.6; }
  100% { transform: scale(1.2); opacity: 0; }
}

@keyframes pulseOutRed {
  0% { transform: scale(1); opacity: 0.6; }
  100% { transform: scale(1.2); opacity: 0; }
}


button.option.selected::after {
  content: "";
  position: absolute;
  top: -6px;
  left: -6px;
  right: -6px;
  bottom: -6px;
  border: 2px solid #007bff;
  border-radius: 1rem;
  opacity: 0.6;
  animation: pulseOut 0.5s ease-out forwards;
  pointer-events: none;
}

@keyframes pulseOut {
  0% {
    transform: scale(1);
    opacity: 0.6;
    border-radius:1rem;
  }
  100% {
    transform: scale(1.2);
    opacity: 0;border-radius:1rem;
  }
}

#nav-buttons {
  display: flex;
  justify-content: center;
  gap: 1.5rem;
  margin-top: 2rem;
}

button.option:hover ,button.option.hover {
  background-color:  rgba(0, 123, 255, 0.3);
  transform: scale(1.05);
  transition: all 0.2s ease;
  box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
}


.nav-button {
  background-color: #f0f0f0;
  border: 2px solid #007bff;
  border-radius: 8px;
  padding: 0.6em 1.2em;
  font-size: 1rem;
  font-weight: bold;
  color: #007bff;
  cursor: pointer;
  transition: all 0.2s ease;
}

#word {
  text-align: center;
  font-size: 3rem;
  margin-top:2rem;
  margin-bottom: 5rem;
}


.nav-button:hover,.nav-button.hover,
.nav-button:focus  {
  background-color: #007bff;
  color: white;
  transform: scale(1.05);
}

.nav-button:active {
  transform: scale(0.97);
}

    .hidden { display: none; }
    .learned { color: green; font-weight: bold; }
    #progress-bar div { height: 20px; }
    #error-words-section {
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid #eee;
    }
    #error-words-display {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #f8f9fa;
      border-radius: 8px;
      word-break: break-all;
    }
  </style>
</head>
<body>
  
  <h2 id="word">åŠ è½½ä¸­...</h2>
  <div id="options"></div>
  <div id="feedback" class="hidden"></div>
  <div id="nav-buttons">
    <button class="nav-button" onclick="prevWord()">â¬…ï¸ ä¸Šä¸€ä¸ªå•è¯</button>
    <button class="nav-button" onclick="nextWord()">ä¸‹ä¸€ä¸ªå•è¯ â¡ï¸</button>
  </div>
  
  <!-- é”™è¯æœ¬æŒ‰é’® -->
  <div id="error-words-buttons" style="display: flex; justify-content: center; gap: 1.5rem; margin-top: 2rem;">
    <button class="nav-button" onclick="generateErrorWords()">ç”Ÿæˆé”™è¯æœ¬</button>
    <button class="nav-button" onclick="clearErrorWords()">æ¸…ç©ºé”™è¯æœ¬</button>
  </div>
  
  <div style="margin-top:2rem"></div>
  <div id="progress-bar" style="display: flex; gap: 2px; margin-top: 30px; border-radius: 10rem; overflow: hidden;"></div>

<!-- çŠ¶æ€ä¸æ¨¡å¼é€‰æ‹© -->
<div id="status-mode" style="display: flex; justify-content: space-between; font-size: 1rem; margin-top: 1rem;">
  <div id="status">å·²å­¦ä¼šï¼š0/0</div>
  <div style="display: flex; gap: 1rem; align-items: center;">
    <label>
      é€‰é¡¹æ•°é‡ï¼š
      <select id="optionCountSelector" onchange="updateOptionCount()">
        <option value="4">4ä¸ªé€‰é¡¹ï¼ˆ1è¡Œï¼‰</option>
        <option value="8">8ä¸ªé€‰é¡¹ï¼ˆ2è¡Œï¼‰</option>
        <option value="12">12ä¸ªé€‰é¡¹ï¼ˆ3è¡Œï¼‰</option>
        <option value="16">16ä¸ªé€‰é¡¹ï¼ˆ4è¡Œï¼‰</option>
      </select>
    </label>
    <label>
      æ¨¡å¼é€‰æ‹©ï¼š
      <select id="modeSelector" onchange="switchMode()">
        <option value="learn">ğŸ§  å­¦ä¹ æ¨¡å¼</option>
        <option value="review">ğŸ“˜ å¤ä¹ æ¨¡å¼</option>
      </select>
    </label>
  </div>
</div>

<div id="progress-input" style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">
  <label>è®¾ç½®å½“å‰å­¦ä¹ è¿›åº¦è‡³å•è¯å·ï¼š</label>
  <input type="number" id="wordNumber" min="1" placeholder="è¾“å…¥å•è¯å·" style="width: 100px; padding: 5px;">
  <button class="nav-button" onclick="setLearningProgress()">è®¾ç½®è¿›åº¦</button>
  <div id="progressFeedback" style="color: #dc3545; margin-left: 10px;"></div>
</div>

<!-- é”™è¯æœ¬å±•ç¤ºåŒºåŸŸ -->
<div id="error-words-section">
  <h3>é”™è¯æœ¬</h3>
  <div id="error-words-display">æš‚æ— é”™è¯è®°å½•</div>
</div>

  <script>
    let words = [];
    let index = 0;
    let batchSize = 20;
    let currentBatchStart = 0;
    let progress = {};
    let reviewProgress = {};
    let errorWords = new Set(); // é”™è¯é›†åˆï¼Œé¿å…é‡å¤
    let mode = 'learn';
    let optionCount = 4; // é»˜è®¤4ä¸ªé€‰é¡¹
    
    const PROGRESS_KEY = "wordProgress";
    const REVIEW_KEY = "reviewProgress";
    const ERROR_WORDS_KEY = "errorWords";
    const OPTION_COUNT_KEY = "optionCount"; // æ–°å¢é€‰é¡¹æ•°é‡å­˜å‚¨é”®
    
    function saveProgress() {
      localStorage.setItem(PROGRESS_KEY, JSON.stringify(progress));
    }
    
    function saveReviewProgress() {
      localStorage.setItem(REVIEW_KEY, JSON.stringify(reviewProgress));
    }
    
    // æ–°å¢ï¼šä¿å­˜é€‰é¡¹æ•°é‡è®¾ç½®
    function saveOptionCount() {
      localStorage.setItem(OPTION_COUNT_KEY, optionCount);
    }
    
    // æ–°å¢ï¼šåŠ è½½é€‰é¡¹æ•°é‡è®¾ç½®
    function loadOptionCount() {
      const saved = localStorage.getItem(OPTION_COUNT_KEY);
      if (saved) {
        optionCount = parseInt(saved);
        document.getElementById("optionCountSelector").value = optionCount;
      }
    }
    
    function saveErrorWords() {
      localStorage.setItem(ERROR_WORDS_KEY, JSON.stringify(Array.from(errorWords)));
    }
    
    function loadProgress() {
      const raw = localStorage.getItem(PROGRESS_KEY);
      if (raw) progress = JSON.parse(raw);
    }
    
    function loadReviewProgress() {
      const raw = localStorage.getItem(REVIEW_KEY);
      if (raw) reviewProgress = JSON.parse(raw);
    }
    
    function loadErrorWords() {
      const raw = localStorage.getItem(ERROR_WORDS_KEY);
      if (raw) errorWords = new Set(JSON.parse(raw));
    }
    
    function initializeProgress(data) {
      if (!progress) progress = {};
      data.forEach(w => {
        if (!(w.å•è¯ in progress)) progress[w.å•è¯] = { streak: 0 };
      });
    }
    
    fetch("/api/words").then(res => res.json()).then(data => {
      words = data;
      loadProgress();
      loadReviewProgress();
      loadErrorWords();
      loadOptionCount(); // æ–°å¢ï¼šåŠ è½½é€‰é¡¹æ•°é‡è®¾ç½®
      initializeProgress(data);
      renderWord();
    });
    
    function shuffle(arr) {
  // Fisher-Yates shuffle
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function getWordsToStudy() {
  if (mode === 'learn') {
    const batch = words.slice(currentBatchStart, currentBatchStart + batchSize);
    const unlearned = batch.filter(w => progress[w.å•è¯].streak < 3);
    shuffle(unlearned);
    return unlearned;
  } else {
    const reviewing = words.filter(w =>
      progress[w.å•è¯]?.streak >= 3 && (reviewProgress[w.å•è¯]?.review ?? 0) > 0
    );
    shuffle(reviewing);
    return reviewing;
  }
}

    
function renderWord() {
  const list = getWordsToStudy();

  const learnedCount = Object.values(progress).filter(p => p.streak >= 3).length;
  const totalCount = words.length;
  const reviewedCount = words.filter(w =>
    progress[w.å•è¯]?.streak >= 3 && (reviewProgress[w.å•è¯]?.review ?? 0) === 0
  ).length;

  if (list.length === 0) {
    if (mode === 'learn') {
      if (currentBatchStart + batchSize >= totalCount) {
        document.getElementById("status").innerHTML = `ğŸ‰ æ‰€æœ‰å•è¯å·²å­¦å®Œï¼ï¼ˆå…± ${learnedCount}/${totalCount}ï¼‰`;
        document.getElementById("word").textContent = "";
        
        document.getElementById("options").innerHTML = "";
        document.getElementById("feedback").classList.add("hidden");
        return;
      } else {
        currentBatchStart += batchSize;
        index = 0;
        renderWord();
        return;
      }
    } else {
      document.getElementById("status").innerHTML = `âœ… å¤ä¹ å®Œæˆï¼ï¼ˆå…±å¤ä¹  ${reviewedCount}/${totalCount}ï¼‰`;
      document.getElementById("word").textContent = "";
      document.getElementById("options").innerHTML = "";
      document.getElementById("feedback").classList.add("hidden");
      return;
    }
  }

  const word = list[index % list.length];
  document.getElementById("word").textContent = word.å•è¯;
  const wordText = document.getElementById("word");
wordText.innerHTML = `${word.å•è¯} <button id="speakBtn" style="font-size: 0.6em;">ğŸ”Š</button>`;

document.getElementById("speakBtn").onclick = () => {
  speakWord(word.å•è¯);
};

  document.getElementById("word").dataset.correct = word.å•è¯é‡Šä¹‰;
  document.getElementById("feedback").classList.add("hidden");

  const correct = word.å•è¯é‡Šä¹‰;
  let options = [correct];
  // æ ¹æ®è®¾ç½®çš„é€‰é¡¹æ•°é‡ç”Ÿæˆå¹²æ‰°é¡¹
  while (options.length < optionCount) {
    let rand = words[Math.floor(Math.random() * words.length)].å•è¯é‡Šä¹‰;
    if (!options.includes(rand)) options.push(rand);
  }
  options.sort(() => Math.random() - 0.5);

  const container = document.getElementById("options");
  container.innerHTML = "";
  options.forEach((opt, i) => {
    const btn = document.createElement("button");
    btn.className = "option";
    btn.textContent = opt;
    btn.onclick = () => {
      const isCorrect = opt === correct;
      highlightOption(i, isCorrect);
      handleAnswer(isCorrect, word);
    };
    container.appendChild(btn);
  });

  document.getElementById("status").textContent =
    mode === 'learn'
      ? `å·²å­¦ä¼šï¼š${learnedCount}/${totalCount}`
      : `å¤ä¹ ä¸­ï¼š${list.length} ä¸ªå•è¯`;

  renderProgressBar();
  speakWord(word.å•è¯);

}

// æ–°å¢ï¼šæ›´æ–°é€‰é¡¹æ•°é‡
function updateOptionCount() {
  optionCount = parseInt(document.getElementById("optionCountSelector").value);
  saveOptionCount();
  renderWord(); // é‡æ–°æ¸²æŸ“å½“å‰å•è¯çš„é€‰é¡¹
}


function setLearningProgress() {
  const input = document.getElementById("wordNumber");
  const feedback = document.getElementById("progressFeedback");
  const maxWordNumber = words.length; // æ€»å•è¯æ•°
  const targetNumber = parseInt(input.value.trim(), 10);

  // è¾“å…¥éªŒè¯
  if (!targetNumber || isNaN(targetNumber) || targetNumber < 1) {
    feedback.textContent = "è¯·è¾“å…¥æœ‰æ•ˆçš„å•è¯å·ï¼ˆè‡³å°‘ä¸º1ï¼‰";
    return;
  }

  if (targetNumber > maxWordNumber) {
    feedback.textContent = `å•è¯å·ä¸èƒ½è¶…è¿‡æ€»å•è¯æ•°ï¼ˆ${maxWordNumber}ï¼‰`;
    return;
  }

  // é‡ç½®æ‰€æœ‰å•è¯çš„å­¦ä¹ è¿›åº¦
  for (let i = 0; i < maxWordNumber; i++) {
    const word = words[i];
    if (word && word.å•è¯) {
      // å¯¹äºç›®æ ‡å•è¯å·ä¹‹å‰çš„å•è¯æ ‡è®°ä¸ºå·²å®Œæˆ
      // ç›®æ ‡åŠä¹‹åçš„å•è¯æ ‡è®°ä¸ºæœªå®Œæˆ
      if (i < targetNumber - 1) {
        progress[word.å•è¯] = { streak: 3 }; // å·²å®Œæˆ
      } else {
        progress[word.å•è¯] = { streak: 0 }; // æœªå®Œæˆ
      }
    }
  }

  // è®¾ç½®å½“å‰å•è¯ç´¢å¼•ä¸ºç›®æ ‡å•è¯å· - 1ï¼ˆå› ä¸ºæ•°ç»„ä»0å¼€å§‹ï¼‰
  currentWordIndex = targetNumber - 1;

  // ä¿å­˜è¿›åº¦å¹¶åˆ·æ–°æ˜¾ç¤º
  saveProgress();
  renderProgressBar();
  renderWord(); // é‡æ–°æ¸²æŸ“å½“å‰å•è¯

  // åé¦ˆæˆåŠŸä¿¡æ¯
  feedback.textContent = `å·²æˆåŠŸè®¾ç½®å­¦ä¹ è¿›åº¦è‡³å•è¯å· ${targetNumber}`;
  input.value = "";
  
  // 3ç§’åæ¸…é™¤åé¦ˆä¿¡æ¯
  setTimeout(() => {
    feedback.textContent = "";
  }, 3000);
}

function handleAnswer(isCorrect, word) {
  const feedback = document.getElementById("feedback");
  const audio = new Audio(isCorrect ? "/correct.wav" : "/wrong.wav");
  audio.play();

  if (isCorrect) {
    if (mode === 'learn') {
      progress[word.å•è¯].streak++;
      if (progress[word.å•è¯].streak > 3) progress[word.å•è¯].streak = 3;
      saveProgress();
    } else {
      if (!reviewProgress[word.å•è¯]) reviewProgress[word.å•è¯] = { review: 1 };
      reviewProgress[word.å•è¯].review--;
      if (reviewProgress[word.å•è¯].review < 0) reviewProgress[word.å•è¯].review = 0;
      saveReviewProgress();
    }
    feedback.textContent = `âœ… æ­£ç¡®ï¼è”æƒ³æ³•ï¼š${word.å•è¯è”æƒ³èƒŒè¯µæ³•}`;
  } else {
    // å›ç­”é”™è¯¯æ—¶å°†å•è¯åŠ å…¥é”™è¯æœ¬
    errorWords.add(word.å•è¯);
    saveErrorWords();
    
    if (mode === 'learn') {
      progress[word.å•è¯].streak = 0;
      saveProgress();
    } else {
      reviewProgress[word.å•è¯] = { review: 3 };
      saveReviewProgress();
    }
    feedback.textContent = `âŒ é”™è¯¯ï¼è”æƒ³æ³•ï¼š${word.å•è¯è”æƒ³èƒŒè¯µæ³•}`;
  }

  feedback.classList.remove("hidden");
}

function speakWord(text) {
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = "en-US";
 //  speechSynthesis.speak(utter);
}

    // ç”Ÿæˆé”™è¯æœ¬
    function generateErrorWords() {
      const display = document.getElementById("error-words-display");
      if (errorWords.size === 0) {
        display.textContent = "æš‚æ— é”™è¯è®°å½•";
        return;
      }
      // ä»¥"å•è¯ï¼Œå•è¯ï¼Œå•è¯"æ ¼å¼æ˜¾ç¤º
      display.textContent = Array.from(errorWords).join("ï¼Œ");
    }
    
    // æ¸…ç©ºé”™è¯æœ¬
    function clearErrorWords() {
      if (confirm("ç¡®å®šè¦æ¸…ç©ºé”™è¯æœ¬å—ï¼Ÿ")) {
        errorWords.clear();
        saveErrorWords();
        document.getElementById("error-words-display").textContent = "é”™è¯æœ¬å·²æ¸…ç©º";
        // 3ç§’åæ¢å¤æ˜¾ç¤ºé»˜è®¤æ–‡æœ¬
        setTimeout(() => {
          document.getElementById("error-words-display").textContent = "æš‚æ— é”™è¯è®°å½•";
        }, 3000);
      }
    }
    
    function nextWord() {
      index++;
      renderWord();
    }
    
    function prevWord() {
      const list = getWordsToStudy();
      index = (index - 1 + list.length) % list.length;
      renderWord();
    }
    
    function switchMode() {
      mode = document.getElementById("modeSelector").value;
      index = 0;
      currentBatchStart = 0;
    
      if (mode === 'review') {
        words.forEach(w => {
          if (progress[w.å•è¯]?.streak >= 3 && !(w.å•è¯ in reviewProgress)) {
            reviewProgress[w.å•è¯] = { review: 1 };
          }
        });
        saveReviewProgress();
      }
    
      renderWord();
    }
    





    function renderProgressBar() {
      const bar = document.getElementById("progress-bar");
      bar.innerHTML = "";
    
      let total = words.length;
      let learned = 0;
      let learning = 0;
    
      if (mode === 'learn') {
        words.forEach(w => {
          let s = progress[w.å•è¯]?.streak ?? 0;
          if (s >= 3) learned++;
          else if (s > 0) learning++;
        });
      } else {
        words.forEach(w => {
          if (progress[w.å•è¯]?.streak >= 3) {
            let r = reviewProgress[w.å•è¯]?.review ?? 0;
            if (r === 0) learned++;
            else learning++;
          }
        });
      }
    
      let learnedPct = (learned / total) * 100;
      let learningPct = (learning / total) * 100;
      let unlearnedPct = 100 - learnedPct - learningPct;
    
      const addSegment = (color, width) => {
        const div = document.createElement("div");
        div.style.width = `${width}%`;
        div.style.height = "20px";
        div.style.backgroundColor = color;
        bar.appendChild(div);
      };
    
      addSegment("#007bff", learnedPct);   // è“è‰²ï¼šå·²å­¦ä¼š
      addSegment("#ffc107", learningPct);  // é»„è‰²ï¼šæ­£åœ¨å­¦
      addSegment("#ccc", unlearnedPct);    // ç°è‰²ï¼šæœªå­¦
    }
    
    function highlightOption(index, isCorrect) {
      const options = document.querySelectorAll("#options button.option");
      options.forEach(btn => btn.classList.remove("correct", "wrong"));
    
      if (options[index]) {
        options[index].classList.add(isCorrect ? "correct" : "wrong");
        setTimeout(() => {
          options[index].classList.remove("correct", "wrong");
        }, 500);
      }
    }
   
// ä¿®æ”¹é”®ç›˜äº‹ä»¶ç›‘å¬é€»è¾‘ï¼Œå®ç°è¡Œ+åˆ—ç»„åˆé€‰æ‹©
let currentRow = null; // è®°å½•å½“å‰æŒ‰ä¸‹çš„è¡Œé”®ï¼ˆq/w/e/rå¯¹åº”0/1/2/3ï¼‰
let currentCol = null; // è®°å½•å½“å‰æŒ‰ä¸‹çš„åˆ—é”®ï¼ˆ1-4/Enterå¯¹åº”0/1/2/3ï¼‰

document.addEventListener("keydown", (e) => {
  const key = e.key.toLowerCase();
  const options = document.querySelectorAll("#options button.option");
  const totalOptions = options.length;
  const rows = Math.ceil(totalOptions / 4); // è®¡ç®—æ€»è¡Œæ•°ï¼ˆæ¯è¡Œ4åˆ—ï¼‰

  // å¤„ç†è¡Œé”®ï¼ˆq/w/e/rï¼‰- å¯¹åº”1-4è¡Œ
  if (["q", "w", "e", "r"].includes(key)) {
    const rowMap = { "q": 0, "w": 1, "e": 2, "r": 3 };
    const row = rowMap[key];
    // åªè®°å½•æœ‰æ•ˆè¡Œï¼ˆä¸è¶…è¿‡å½“å‰æ€»è¡Œåˆ—æ•°ï¼‰
    if (row < rows) {
      currentRow = row;
    }
  }

  // å¤„ç†åˆ—é”®ï¼ˆ1-4/Enterï¼‰- å¯¹åº”1-4åˆ—
  else if (["1", "2", "3", "4"].includes(key) || key === "enter") {
    const colMap = { "1": 0, "2": 1, "3": 2, "4": 3, "enter": 3 };
    currentCol = colMap[key];
  }

  // å½“è¡Œå’Œåˆ—éƒ½å·²ç¡®å®šæ—¶ï¼Œè®¡ç®—é€‰é¡¹ç´¢å¼•å¹¶è§¦å‘é€‰æ‹©
  if (currentRow !== null && currentCol !== null) {
    const index = currentRow * 4 + currentCol;
    // æ£€æŸ¥ç´¢å¼•æ˜¯å¦æœ‰æ•ˆï¼ˆä¸è¶…è¿‡é€‰é¡¹æ€»æ•°ï¼‰
    if (index < totalOptions && options[index]) {
      const correctAnswer = document.getElementById("word").dataset.correct;
      
      // æ·»åŠ è§†è§‰åé¦ˆ
      options[index].classList.add("hover");
      setTimeout(() => options[index].classList.remove("hover"), 150);
      
      // è§¦å‘é€‰æ‹©é€»è¾‘
      highlightOption(index, options[index].textContent === correctAnswer);
      options[index].click();
    }
    
    // é‡ç½®é€‰æ‹©çŠ¶æ€ï¼Œé¿å…é‡å¤è§¦å‘
    currentRow = null;
    currentCol = null;
  }
});

// æŒ‰é”®é‡Šæ”¾æ—¶é‡ç½®å¯¹åº”çŠ¶æ€
document.addEventListener("keyup", (e) => {
  const key = e.key.toLowerCase();
  if (["q", "w", "e", "r"].includes(key)) {
    currentRow = null;
  } else if (["1", "2", "3", "4", "enter"].includes(key)) {
    currentCol = null;
  }
});



    </script>
    
</body>
</html>